# VidCast 技術詳解

## 架構概覽（v1.1.0 字幕優先架構）

```
┌─────────────┐
│  User       │
│  Interface  │
└──────┬──────┘
       │
       ▼
┌─────────────────┐      ┌──────────────┐
│  VidCastWidget  │─────▶│  Firebase    │
│  (React)        │◀─────│  Auth        │
└────────┬────────┘      └──────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│  /api/summarize (Node.js Runtime)       │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────┐
│  fetchSubtitles │ ◀── youtube-transcript
│  (subtitle.ts)  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  preprocess     │ ◀── 清理、分段、抽數字
│  (preprocess.ts)│
└────────┬────────┘
         │
         ▼
┌─────────────────┐      ┌─────────────────┐
│ analyzeWith     │      │ analyzeWith     │
│ Subtitles()     │  OR  │ Fallback()      │
│ (有字幕)        │      │ (無字幕降級)    │
└────────┬────────┘      └────────┬────────┘
         │                        │
         ▼                        ▼
┌────────────────────────────────────┐
│  Google Gemini API                 │
│  - 2.5 Flash Lite (字幕分析)       │
└────────┬───────────────────────────┘
         │
         ▼
┌─────────────────┐
│  postprocess    │ ◀── 解析 JSON、校驗數字
│  (postprocess.ts)│
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│  /api/tts (Node.js Runtime)             │
└────────┬────────────────────────────────┘
         │
         ▼
┌────────────────────────────────────┐
│  Google Gemini TTS API             │
│  - 2.5 Flash Preview TTS           │
└────────────────────────────────────┘
```

## API 端點

### POST /api/summarize

**位置**: `app/api/summarize/route.ts`

**Runtime**: `nodejs`（字幕套件需要 Node.js）

**請求格式**:
```typescript
interface SummarizeRequest {
  videoUrl: string;          // YouTube URL（必需）
  apiKey: string;            // Gemini API Key（必需）
}
```

**請求範例**:
```json
{
  "videoUrl": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
  "apiKey": "AIzaSyD..."
}
```

**響應格式（v1.1.0）**:
```typescript
interface Fact {
  id: number;
  time: string;              // "00:00-02:30"
  fact: string;              // 具體事實描述
}

interface SummarizeResponse {
  success: boolean;
  textSummary: string;       // 播報式文字摘要
  facts: Fact[];             // 事實清單
  confidence: 'high' | 'medium' | 'low';
  warnings: string[];        // 警告訊息
  hasSubtitles: boolean;     // 是否有字幕
  audioUrl: string | null;   // TTS 音頻（由 /api/tts 單獨生成）
}
```

**成功響應範例**:
```json
{
  "success": true,
  "textSummary": "這段視頻介紹了最新的 AI 技術發展...",
  "facts": [
    { "id": 1, "time": "00:00-02:30", "fact": "OpenAI 發布了 GPT-5" },
    { "id": 2, "time": "02:30-05:00", "fact": "訓練成本降低 50%" }
  ],
  "confidence": "high",
  "warnings": [],
  "hasSubtitles": true,
  "audioUrl": null
}
```

**可信度說明**:
- `high`：有字幕 + 所有數字已驗證 + 3+ facts
- `medium`：有字幕 + 1-2 個數字未驗證
- `low`：無字幕（僅基於標題+作者，由 oEmbed 獲取）

### POST /api/tts

**位置**: `app/api/tts/route.ts`

**Runtime**: `nodejs`（Buffer 操作需要 Node.js）

**請求格式**:
```typescript
interface TTSRequest {
  text: string;              // 要轉換的文字
  apiKey: string;            // Gemini API Key
}
```

**響應格式**:
```typescript
interface TTSResponse {
  success: boolean;
  audioUrl: string;          // data:audio/wav;base64,...
}
```

**錯誤響應**:
```typescript
interface ErrorResponse {
  error: string;             // 錯誤訊息
  details?: any;             // 詳細錯誤資訊（開發模式）
}
```

**錯誤範例**:
```json
{
  "error": "請輸入有效的 YouTube 連結"
}
```

---

## 核心模塊（v1.1.0 新增）

### 0. 字幕抓取模組

**位置**: `lib/vidcast/subtitle.ts`

**依賴**: `youtube-transcript`, `server-only`

**函式**:
- `fetchSubtitles(videoUrl, preferredLang)` - 抓取 YouTube 字幕
- `fetchVideoMetadata(videoUrl)` - 抓取視頻 metadata（oEmbed API）

**輸出格式**:
```typescript
interface SubtitleSegment {
  start: number;    // 開始時間（秒）
  end: number;      // 結束時間（秒）
  text: string;     // 字幕文字
}

interface SubtitleResult {
  available: boolean;
  language: string;
  isAutoGenerated: boolean;
  segments: SubtitleSegment[];
  totalDuration: number;
  error?: string;
}
```

---

### 0.1 前處理模組

**位置**: `lib/vidcast/preprocess.ts`

**功能**:
- 清理口頭語（嗯嗯、那個、這個、就是說）
- 分段（每 2-3 分鐘或 500-800 字）
- 預抽取數字（金額、年份、百分比）

**輸出格式**:
```typescript
interface PreprocessResult {
  segments: ProcessedSegment[];
  extractedNumbers: ExtractedNumber[];
  metadata: {
    totalDuration: number;
    segmentCount: number;
    totalCharacters: number;
  };
}
```

---

### 0.2 後處理校驗模組

**位置**: `lib/vidcast/postprocess.ts`

**功能**:
- 解析模型返回的 JSON
- 提取 summary 中的數字
- 檢查數字是否在 facts 中
- 未驗證的數字標記「（待驗證）」
- 計算 confidence 等級

**輸出格式**:
```typescript
interface ValidatedResult {
  facts: Fact[];
  summary: string;
  confidence: 'high' | 'medium' | 'low';
  warnings: string[];
}
```

---

### 1. YouTube URL 驗證

**位置**: `widgets/vidcast/gemini.ts`

**函式**: `validateYouTubeUrl(url: string)`

**支持的 URL 格式**:
```regex
/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/
```

**範例**:
```typescript
validateYouTubeUrl('https://www.youtube.com/watch?v=dQw4w9WgXcQ');
// { valid: true }

validateYouTubeUrl('https://www.youtube.com/shorts/abc123');
// { valid: true }

validateYouTubeUrl('https://youtu.be/dQw4w9WgXcQ');
// { valid: true }

validateYouTubeUrl('https://example.com');
// { valid: false, error: '請輸入有效的 YouTube 連結' }
```

---

### 2. 視頻分析模塊（v1.1.0 字幕優先）

**位置**: `widgets/vidcast/gemini.ts`

**主要函式**:
- `analyzeWithSubtitles(apiKey, promptContent)` - 字幕分析（主流程）
- `analyzeWithFallback(apiKey, title, description)` - 無字幕降級

**Gemini 模型**: `gemini-2.5-flash-lite`

**Prompt 設計（字幕分析）**:
```typescript
function generateFactsBasedPrompt(preprocessedContent: string): string {
  return `
你將收到 YouTube 視頻的字幕內容（含時間區間）和預抽取的數字清單。

## 輸入內容
${preprocessedContent}

## 輸出要求
請輸出 JSON 格式：
{
  "facts": [
    { "id": 1, "time": "00:00-02:30", "fact": "具體事實描述" }
  ],
  "summary": "播報式摘要文字"
}

## 約束
- summary 中的數字必須出現在 facts 中
- 若資訊不確定，標註「未明確提及」
- 數字必須帶單位（億/萬/台）
  `.trim();
}
```

**實現細節（字幕分析）**:
```typescript
export async function analyzeWithSubtitles(
  apiKey: string,
  promptContent: string
): Promise<string> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash-lite' });

  const prompt = generateFactsBasedPrompt(promptContent);

  const result = await model.generateContent([{ text: prompt }]);
  return result.response.text();
}
```

**降級模式（無字幕）**:
```typescript
export async function analyzeWithFallback(
  apiKey: string,
  title: string,
  description: string  // 實際傳入: `作者: ${metadata.author}`
): Promise<string> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash-lite' });

  const prompt = `
僅基於以下資訊生成概述：
- 標題：${title}
- 描述：${description || '（無描述）'}

規則：
- 只描述視頻的大致主題
- 禁止包含任何數字、人名或具體結論
- 長度：100-200 字
- 語氣：「這個視頻似乎討論了...」

輸出 JSON：
{ "facts": [], "summary": "概述文字" }
  `.trim();

  const result = await model.generateContent([{ text: prompt }]);
  return result.response.text();
}
```

**舊版函式（已棄用）**:
```typescript
// 以下函式保留於 gemini.ts 但不再用於主流程
// - analyzeVideo(apiKey, videoUrl) - 使用 fileData 多模態分析
// - analyzeVideoWithToken(accessToken, videoUrl) - OAuth 版本
// 這些函式可能用於未來的 OAuth 流程或特殊場景
```

**錯誤處理**:
```typescript
try {
  const result = await analyzeWithSubtitles(apiKey, promptContent);
} catch (error: any) {
  if (error.message?.includes('API key')) {
    throw new Error('API Key 無效或已過期');
  } else if (error.message?.includes('quota') || error.message?.includes('429')) {
    throw new Error('API 配額已用完，請稍後再試');
  } else if (error.message?.includes('503') || error.message?.includes('overloaded')) {
    throw new Error('Google 服務暫時過載，請稍候 1-2 分鐘後再試');
  } else if (error.message?.includes('video')) {
    throw new Error('無法訪問該視頻，請確認視頻為公開狀態');
  }
  throw new Error('視頻分析失敗，請稍後再試');
}
```

---

### 3. TTS 語音合成模塊

**位置**: `widgets/vidcast/gemini.ts`

**函式**:
- `generateTTS(apiKey: string, text: string)` - 使用 API Key
- `generateTTSWithToken(accessToken: string, text: string)` - 使用 OAuth

**Gemini 模型**: `gemini-2.5-flash-preview-tts`

**音色**: `Kore`（自然、專業、中文友好）

**文字清理**:
```typescript
function cleanTextForTTS(text: string): string {
  return text
    // 移除 Markdown 標題符號
    .replace(/^#{1,6}\s+/gm, '')
    // 移除粗體和斜體
    .replace(/\*\*([^*]+)\*\*/g, '$1')
    .replace(/\*([^*]+)\*/g, '$1')
    // 移除列表符號
    .replace(/^[\s]*[-*+]\s+/gm, '')
    .replace(/^\d+\.\s+/gm, '')
    // 移除多餘空行
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}
```

**長度限制**:
```typescript
const maxLength = 5000;  // 約 7500 tokens，支持長視頻完整播報
const truncatedText = cleanedText.length > maxLength
  ? cleanedText.slice(0, maxLength) + '...'
  : cleanedText;
```

**PCM 轉 WAV**:
```typescript
function pcmToWav(pcmData: string): string {
  const pcmBuffer = Buffer.from(pcmData, 'base64');

  // WAV 文件頭參數
  const sampleRate = 24000;
  const numChannels = 1;
  const bitsPerSample = 16;

  // 創建 44 bytes WAV header
  const header = Buffer.alloc(44);

  // RIFF chunk
  header.write('RIFF', 0);
  header.writeUInt32LE(36 + pcmBuffer.length, 4);
  header.write('WAVE', 8);

  // fmt sub-chunk
  header.write('fmt ', 12);
  header.writeUInt32LE(16, 16);
  header.writeUInt16LE(1, 20);          // PCM
  header.writeUInt16LE(numChannels, 22);
  header.writeUInt32LE(sampleRate, 24);
  header.writeUInt32LE(sampleRate * numChannels * bitsPerSample / 8, 28);
  header.writeUInt16LE(numChannels * bitsPerSample / 8, 32);
  header.writeUInt16LE(bitsPerSample, 34);

  // data sub-chunk
  header.write('data', 36);
  header.writeUInt32LE(pcmBuffer.length, 40);

  // 合併 header 和 PCM 數據
  const wavBuffer = Buffer.concat([header, pcmBuffer]);

  return `data:audio/wav;base64,${wavBuffer.toString('base64')}`;
}
```

**完整實現**:
```typescript
async function generateTTS(apiKey: string, text: string): Promise<string | null> {
  try {
    const cleanedText = cleanTextForTTS(text);
    const truncatedText = cleanedText.length > 5000
      ? cleanedText.slice(0, 5000) + '...'
      : cleanedText;

    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({
      model: 'gemini-2.5-flash-preview-tts',
    });

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: [{ text: truncatedText }] }],
      generationConfig: {
        responseModalities: ['AUDIO'],
        speechConfig: {
          voiceConfig: {
            prebuiltVoiceConfig: {
              voiceName: 'Kore',
            },
          },
        },
      },
    });

    const audioData = result.response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;

    if (!audioData) {
      console.warn('TTS 生成失敗，未返回音頻數據');
      return null;
    }

    return pcmToWav(audioData);
  } catch (error) {
    console.error('TTS 生成錯誤:', error);
    return null;  // TTS 失敗不影響主流程
  }
}
```

---

## Firebase 認證

### 配置

**位置**: `lib/firebase.ts`

```typescript
import { initializeApp } from 'firebase/app';
import { getAuth, GoogleAuthProvider } from 'firebase/auth';

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const googleProvider = new GoogleAuthProvider();
```

### OAuth 流程

```typescript
import { signInWithPopup } from 'firebase/auth';
import { auth, googleProvider } from '@/lib/firebase';

async function handleGoogleLogin() {
  const result = await signInWithPopup(auth, googleProvider);
  const credential = GoogleAuthProvider.credentialFromResult(result);
  const accessToken = credential?.accessToken;  // 用於 Gemini API
  const user = result.user;

  return { accessToken, user };
}
```

---

## 環境變數

**必需的環境變數** (`.env.local`):

```bash
# Firebase 配置
NEXT_PUBLIC_FIREBASE_API_KEY=AIzaSy...
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your-app.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your-project-id

# 可選：Server-side Gemini API Key（用於測試）
GEMINI_API_KEY=AIzaSy...
```

---

## 性能考慮

### 視頻分析
- **平均時間**: 10-30 秒（取決於視頻長度）
- **超時設置**: 60 秒（Vercel/Render 通用配置）
- **重試策略**: 遇到 503 錯誤時提示用戶稍後重試

### TTS 生成
- **平均時間**: 2-5 秒/分鐘音頻
- **超時設置**: 60 秒
- **失敗處理**: 返回 null，不影響文字摘要

### 緩存策略
目前未實現緩存，每次請求都會調用 Gemini API。

**未來改進**:
```typescript
// Redis 緩存範例
const cacheKey = `vidcast:${youtubeUrl}`;
const cached = await redis.get(cacheKey);
if (cached) return JSON.parse(cached);

// ... 調用 Gemini ...

await redis.set(cacheKey, JSON.stringify(result), 'EX', 3600);  // 1 小時
```

---

## 錯誤處理

| 錯誤碼 | 說明 | 用戶友好訊息 |
|-------|------|------------|
| 400 | 無效 URL 格式 | "請輸入有效的 YouTube 連結" |
| 401 | API Key 無效 | "API Key 無效或已過期" |
| 403 | 無權訪問視頻 | "無法訪問該視頻，請確認視頻為公開狀態" |
| 429 | 配額限制 | "API 配額已用完，請稍後再試（或更換 API Key）" |
| 503 | 服務過載 | "Google 服務暫時過載，請稍候 1-2 分鐘後再試" |
| 500 | 其他錯誤 | "視頻分析失敗，請稍後再試" |

---

## 依賴項

**核心依賴**:
```json
{
  "@google/generative-ai": "^0.24.1",
  "firebase": "^10.13.0",
  "next": "^15.1.3",
  "react": "^18.3.1",
  "youtube-transcript": "^1.2.1",
  "server-only": "^0.0.1"
}
```

**開發依賴**:
```json
{
  "typescript": "^5",
  "@types/node": "^20",
  "@types/react": "^18"
}
```

---

## 安全性

### API Key 保護
- ✅ 用戶 API Key 存儲在 localStorage（僅客戶端）
- ✅ OAuth Token 通過 Firebase 管理
- ⚠️ 未加密存儲（瀏覽器 localStorage 本質上不安全）

### 建議改進
- 使用 Server-side API Key Pool
- 實現 Rate Limiting
- 添加 CAPTCHA 防止濫用

### CORS 設置
Next.js API Routes 默認允許所有來源，建議添加限制：

```typescript
// middleware.ts
export function middleware(request: NextRequest) {
  const origin = request.headers.get('origin');
  if (origin && !allowedOrigins.includes(origin)) {
    return new Response('Forbidden', { status: 403 });
  }
  return NextResponse.next();
}
```

---

## 監控與日誌

### 日誌格式
```typescript
console.log('[Summarize] 開始分析視頻:', videoUrl);
console.log('[Summarize] 開始生成 TTS');
console.error('[Summarize] 錯誤:', error.message);
```

### 建議監控指標
- API 調用次數（per user, per day）
- 平均響應時間
- 錯誤率（按錯誤碼分類）
- TTS 使用量

### 未來改進
- 整合 Sentry 或 LogRocket
- 添加 Analytics 追蹤
- 實現用戶使用統計儀表板

---

## 版本歷史

### v1.1.0 (2025-12-25)
- **字幕優先架構**：提升摘要準確性
- **新增模組**：
  - `lib/vidcast/subtitle.ts`：字幕抓取
  - `lib/vidcast/preprocess.ts`：前處理（清理、分段、抽數字）
  - `lib/vidcast/postprocess.ts`：後處理校驗
- **Facts-based 生成**：輸出結構化 JSON
- **可信度指標**：high / medium / low
- **數字驗證**：未驗證的數字標記「（待驗證）」
- **無字幕降級**：僅基於標題+作者（oEmbed），嚴格限制輸出
- **Runtime 變更**：Edge → Node.js（字幕套件 + Buffer 需要）
- **新增依賴**：`youtube-transcript`, `server-only`

### v1.0.0 (2025-12-24)
- 初始版本
- Gemini 2.5 Flash Lite 視頻分析
- Gemini 2.5 Flash Preview TTS
- Firebase Google OAuth
- TTS 使用計數器
- 播報式 Prompt 優化

---

## 相關文件

- [SKILL.md](./SKILL.md) - Skill 定義和使用說明
- [USAGE.md](./USAGE.md) - 使用示例
- [核心實現](../../../widgets/vidcast/gemini.ts)
- [API Route](../../../app/api/summarize/route.ts)
